#version 330 core

in vec2 v_TexCoord;
in vec2 v_OneTexel;

uniform sampler2D u_Texture;
uniform bool u_Image;
uniform sampler2D u_Overlay;
uniform float u_OverlayAlpha;
uniform int u_Width;
uniform bool u_FastLines;
uniform int u_ShapeMode;
uniform bool u_GlowInner;
uniform int u_GlowQuality;
uniform float u_Time;
uniform vec4 u_FillColor;
uniform vec4 u_FillColor2;
uniform vec4 u_OutlineColor;
uniform vec4 u_OutlineColor2;
uniform int u_Dots;
uniform int u_DotsRadius;
uniform float u_DotsAlpha;
uniform float u_Step;
uniform float u_Glow;

out vec4 color;

float blur(vec4 center, bool outline) {
    if (u_Width == 0.0) return 0.0;

    int w = u_GlowQuality * u_Width;
    float blurred = 0.0;

    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(w, 0)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(-w, 0)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(0, w)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(0, -w)).a;

    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(w, w)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(w, -w)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(-w, w)).a;
    blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(-w, -w)).a;

    if (u_FastLines && u_Width > 2 && blurred == (outline ? 0.0 : 8.0)) {
        return outline ? 0.0 : 1.0;
    }

    blurred = 0.0;
    for (int x = -w; x <= w; x += u_GlowQuality) {
        for (int y = -w; y <= w; y += u_GlowQuality) {
            blurred += texture(u_Texture, v_TexCoord + v_OneTexel * vec2(x, y)).a;
        }
    }

    return clamp(blurred / (((u_Width * u_Width) + u_Width) * 4), 0.0, 1.0);
}

vec4 gradient(vec4 rgb, vec4 rgb2, float step, float time) {
    vec2 frag = vec2(gl_FragCoord.xy);
    float distance = frag.x + frag.y;

    distance = distance / step;

    distance = ((sin(distance + time) + 1.0) / 2.0);

    float distanceInv = 1. - distance;
    float r = rgb.r * distance + rgb2.r * distanceInv;
    float g = rgb.g * distance + rgb2.g * distanceInv;
    float b = rgb.b * distance + rgb2.b * distanceInv;
    float a = rgb.a * distance + rgb2.a * distanceInv;
    return vec4(r, g, b, a);
}

void main() {
    vec4 center = texture(u_Texture, v_TexCoord);

    vec4 outline = gradient(u_OutlineColor, u_OutlineColor2, u_Step * 300., u_Time);

    if (center.a != 0.0) {
        vec4 fill = gradient(u_FillColor, u_FillColor2, u_Step * 300., u_Time);
        if (decorator(u_Dots, u_DotsRadius)) {
            center = vec4(fill.rgb, u_DotsAlpha);
        } else if (u_Image) {
            vec4 overlay = texture(u_Overlay, v_TexCoord * vec2(1.0, -1.0));
            if (overlay.a == 0.0) discard;
            center.rgb = mix(overlay.rgb, fill.rgb, fill.a);
            center.a = u_OverlayAlpha;
        } else {
            center = fill;
        }
        if (u_Width != 0 && u_GlowInner) {
            center = mix(bloom(outline, u_Glow), center, blur(center, false));
        }
    } else if (u_Width > 0.0) {
        float blurFactor = blur(center, true) * u_Glow;
        if (blurFactor == 0.0) discard;

        if (u_GlowQuality * u_Width > 1) {
            for (int x = -1; x <= 1; x++) {
                for (int y = -1; y <= 1; y++) {
                    if (x == 0 && y == 0)
                        continue;

                    if (texture(u_Texture, v_TexCoord + v_OneTexel * vec2(x, y)).a > 0.0) {
                        center = outline;
                        center.a = 1.0;
                    }
                }
            }
        }

        if (center.a == 0.0) {
            center = outline;
            center.a *= blurFactor;
        }
    }

    color = center;
}
